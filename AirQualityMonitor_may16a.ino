#include "arduino_secrets.h"
#include <Arduino_ConnectionHandler.h>
#include <ArduinoIoTCloud.h>
#include "thingProperties.h"  // This will be generated by Arduino IoT Cloud

#include <Wire.h>
#include <DHT.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_SSD1306.h>

// Pin Definitions
#define DHT_PIN 4
#define MQ135_PIN 34
#define RGB_RED_PIN 25
#define RGB_GREEN_PIN 26
#define RGB_BLUE_PIN 27
#define RELAY_PIN 16

// OLED Display
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// DHT Sensor
#define DHTTYPE DHT11
DHT dht(DHT_PIN, DHTTYPE);

// MQ135 Sensor
#define MQ135_CALIBRATION_SAMPLE_TIMES 50
#define MQ135_CALIBRATION_SAMPLE_INTERVAL 500

// Define thresholds
#define AIR_QUALITY_GOOD 800
#define AIR_QUALITY_MODERATE 1200

// Predictive Analysis
#define HISTORY_SIZE 450  // Store 15 minutes of data (450 readings at 2-second intervals)
#define PREDICTION_WINDOW 900  // Predict 15 minutes ahead (900 seconds)
#define TREND_WINDOW 30  // Use last 30 points for trend analysis

// Historical data storage
float airQualityHistory[HISTORY_SIZE];
unsigned long timeHistory[HISTORY_SIZE];
int historyIndex = 0;
bool historyFull = false;

// Prediction variables
float prediction = 0;
float trendSlope = 0;
float shortTermAverage = 0;
float longTermAverage = 0;


// Track previous ventilation speed
String previousVentilationSpeed = "off";
bool speedChanged = false;


// Reading intervals
unsigned long previousMillis = 0;
const long interval = 2000;  // 2 seconds

// Moving average filter for MQ135
int mq135Readings[5] = {0};
int readIndex = 0;
int mq135Sum = 0;
int mq135Average = 0;

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  delay(1500);

  // Initialize pins
  pinMode(RGB_RED_PIN, OUTPUT);
  pinMode(RGB_GREEN_PIN, OUTPUT);
  pinMode(RGB_BLUE_PIN, OUTPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, LOW); // Start with ventilation off

  // Initialize sensors
  initSensors();
  
  // Initialize display
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(0, 0);
  display.println("Starting system...");
  display.display();

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you'll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  display.println("Connecting to Cloud...");
  display.display();
}

void loop() {
  ArduinoCloud.update();
  
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    
    // Read sensors
    readSensors();
    
    // Store historical data
    storeHistoricalData();
    
    // Update prediction
    updatePrediction();
    
    // Update display
    updateDisplay();
    
    // Update RGB indicator
    updateRGBIndicator();
    
    // Control ventilation based on air quality and prediction
    controlVentilation();
  }
}

void initSensors() {
  dht.begin();
  
  // MQ135 warm-up message
  Serial.println("MQ135 warming up. For best results, allow several minutes for stabilization.");
  Serial.println("Taking initial readings for calibration...");
  
  // Take initial readings for calibration
  float mq135Sum = 0;
  for (int i = 0; i < MQ135_CALIBRATION_SAMPLE_TIMES; i++) {
    mq135Sum += analogRead(MQ135_PIN);
    delay(MQ135_CALIBRATION_SAMPLE_INTERVAL / 10);  // Reduced to speed up initial setup
  }
  
  // Calculate baseline
  float mq135Baseline = mq135Sum / MQ135_CALIBRATION_SAMPLE_TIMES;
  Serial.print("MQ135 baseline value: ");
  Serial.println(mq135Baseline);
}

void readSensors() {
  // Read DHT11 data
  float tempHumidity = dht.readHumidity();
  float tempTemperature = dht.readTemperature();
  
  // Check if DHT11 readings are valid
  if (isnan(tempHumidity) || isnan(tempTemperature)) {
    Serial.println("Failed to read from DHT sensor!");
  } else {
    humidity = tempHumidity;
    temperature = tempTemperature;
  }
  
  // Read MQ135 data with moving average filter
  // Remove the oldest reading from the sum
  mq135Sum = mq135Sum - mq135Readings[readIndex];
  
  // Read from the sensor
  mq135Readings[readIndex] = analogRead(MQ135_PIN);
  
  // Add the new reading to the sum
  mq135Sum = mq135Sum + mq135Readings[readIndex];
  
  // Advance to the next position in the array
  readIndex = (readIndex + 1) % 5;
  
  // Calculate the average
  mq135Average = mq135Sum / 5;
  
  // Convert analog reading to ppm (approximate)
  int tempAirQuality = map(mq135Average, 0, 4095, 400, 2000);
   
  // Convert ppm to percentage (0-100) for gauge display
  // Map 400-2000 ppm to 0-100%
  int airQualityPercentage = map(tempAirQuality, 400, 2000, 0, 100);
  
  // Store the percentage value for the gauge
  airQuality = airQualityPercentage;
  
  Serial.print("Temperature: ");
  Serial.print(temperature);
  Serial.print(" Â°C, Humidity: ");
  Serial.print(humidity);
  Serial.print(" %, Air Quality: ");
   Serial.print(airQualityPercentage);
  Serial.print("%, Raw PPM: ");
  Serial.print(tempAirQuality);
  Serial.println(" ppm CO2 eq.");
}

void storeHistoricalData() {
  // Store current air quality and time
  airQualityHistory[historyIndex] = airQuality;
  timeHistory[historyIndex] = millis();
  
  // Update index
  historyIndex = (historyIndex + 1) % HISTORY_SIZE;
  if (historyIndex == 0) {
    historyFull = true;
  }
}

void updatePrediction() {
  if (!historyFull && historyIndex < TREND_WINDOW) {
    return;  // Need enough data points for prediction
  }
  
  // Calculate short-term and long-term averages
  float shortTermSum = 0;
  float longTermSum = 0;
  int shortTermCount = 0;
  int longTermCount = 0;
  
  // Calculate averages using the most recent data
  int currentIndex = (historyIndex - 1 + HISTORY_SIZE) % HISTORY_SIZE;
  for (int i = 0; i < HISTORY_SIZE; i++) {
    int index = (currentIndex - i + HISTORY_SIZE) % HISTORY_SIZE;
    if (i < TREND_WINDOW) {
      shortTermSum += airQualityHistory[index];
      shortTermCount++;
    }
    if (i < HISTORY_SIZE) {
      longTermSum += airQualityHistory[index];
      longTermCount++;
    }
  }
  
  shortTermAverage = shortTermSum / shortTermCount;
  longTermAverage = longTermSum / longTermCount;
  
  // Calculate trend using linear regression on recent data
  float sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
  for (int i = 0; i < TREND_WINDOW; i++) {
    int index = (currentIndex - i + HISTORY_SIZE) % HISTORY_SIZE;
    float x = i;  // Use relative time
    float y = airQualityHistory[index];
    sumX += x;
    sumY += y;
    sumXY += x * y;
    sumX2 += x * x;
  }
  
  // Calculate slope and intercept
  // Calculate trend slope
  trendSlope = (TREND_WINDOW * sumXY - sumX * sumY) / (TREND_WINDOW * sumX2 - sumX * sumX);
  
  // Calculate prediction using weighted combination of:
  // 1. Current value
  // 2. Short-term trend
  // 3. Long-term average
  float currentValue = airQualityHistory[currentIndex];
  float trendPrediction = currentValue + (trendSlope * (PREDICTION_WINDOW / 2000.0));  // Convert to number of 2-second intervals
  
  // Weight the predictions (adjust weights based on testing)
  prediction = (0.4 * currentValue) + (0.4 * trendPrediction) + (0.2 * longTermAverage);
  
  // Ensure prediction stays within reasonable bounds
  prediction = constrain(prediction, 0, 100);

   predictedAirQuality = prediction;

  
  // Print prediction details for debugging
  Serial.print("Current: ");
  Serial.print(currentValue);
  Serial.print(" Trend: ");
  Serial.print(trendSlope);
  Serial.print(" Predicted: ");
  Serial.println(prediction);
}


void updateDisplay() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("Air Quality Monitor");
  display.drawLine(0, 10, display.width(), 10, WHITE);
  
  // Temperature and Humidity
  display.setCursor(0, 15);
  display.print("Temp:");
  display.print(temperature);
  display.println(" C");
  
  display.setCursor(0, 25);
  display.print("Hum:");
  display.print(humidity);
  display.println(" %");
  
  // Second column (right side)
  display.setCursor(64, 15);
  display.print("AQ:");
  display.print(airQuality);
  display.println("%");
  
  display.setCursor(60, 25);
  display.print("Pred:");
  display.print(prediction, 1);  // Show only 1 decimal place
  display.println("%");
  
   // Status line
  display.setCursor(0, 45);
  display.print("Status: ");
   // Convert percentage back to ppm for status check
  int tempAirQuality = map(airQuality, 0, 100, 400, 2000);
  if (tempAirQuality < AIR_QUALITY_GOOD) {
    display.println("GOOD");
  } else if (tempAirQuality < AIR_QUALITY_MODERATE) {
    display.println("MODERATE");
  } else {
    display.println("POOR");
  }
  
  // Ventilation status
  display.setCursor(0, 55);
  display.print("Vent: ");
  display.print(ventilationStatus ? "ON" : "OFF");
  if (ventilationStatus) {
    display.print(" (");
    display.print(ventilationSpeed);
    display.print(")");
  }
  
  display.display();
}

void updateRGBIndicator() {
  // Convert percentage back to ppm for RGB logic
  int tempAirQuality = map(airQuality, 0, 100, 400, 2000);
  if (tempAirQuality < AIR_QUALITY_GOOD) {
    // Good air quality - Green
    setRGBColor(0, 255, 0);
  } else if (tempAirQuality < AIR_QUALITY_MODERATE) {
    // Moderate air quality - Blue
    setRGBColor(0, 0, 255);
  } else {
    // Poor air quality - Red
    setRGBColor(255, 0, 0);
  }
}

void setRGBColor(int r, int g, int b) {
  // Note: Assuming common cathode RGB LED
  analogWrite(RGB_RED_PIN, r);
  analogWrite(RGB_GREEN_PIN, g);
  analogWrite(RGB_BLUE_PIN, b);
}

void controlVentilation() {
    // Convert percentage back to ppm for ventilation control
  int tempAirQuality = map(airQuality, 0, 100, 400, 2000);
  int predictedQuality = map(prediction, 0, 100, 400, 2000);
  
  // Use weighted combination of current and predicted values
  float weightedQuality = (0.7 * tempAirQuality) + (0.3 * predictedQuality);

  // Hysteresis control for ventilation
  if (weightedQuality > AIR_QUALITY_GOOD && !ventilationStatus) {
    // Turn on ventilation if weighted quality is above good
    ventilationStatus = true;
    digitalWrite(RELAY_PIN, HIGH);
    Serial.println("Ventilation activated (based on weighted quality)");
    
    // Set initial speed based on weighted quality
    if (weightedQuality > 1200) {  // Changed to 1200 for high speed
      ventilationSpeed = "high";
    Serial.println("Ventilation speed set to high");
    } else {
      ventilationSpeed = "medium";
      Serial.println("Ventilation speed set to medium");
    }
  } 
  else if (weightedQuality <= AIR_QUALITY_GOOD - 50 && ventilationStatus) {
    // Turn off ventilation if air quality has improved enough
    ventilationStatus = false;
    ventilationSpeed = "off";
    digitalWrite(RELAY_PIN, LOW);
    Serial.println("Ventilation deactivated");
  }
  else if (ventilationStatus) {
    // Add hysteresis to speed changes
    static int lastSpeedChange = 0;
    if (millis() - lastSpeedChange > 10000) {  // Only change speed every 10 seconds
      String newSpeed = ventilationSpeed;  // Store current speed before potential change
 
      if (weightedQuality > 1200) {  // Changed to 1200 for high speed
        if (ventilationSpeed != "high") {
          ventilationSpeed = "high";
          Serial.println("Ventilation speed set to high");
          lastSpeedChange = millis();
        }
      } 
      else {
        if (ventilationSpeed != "medium") {
          ventilationSpeed = "medium";
          Serial.println("Ventilation speed set to medium");
          lastSpeedChange = millis();
        }
      }
            
      // Update previous speed after potential change
      previousVentilationSpeed = newSpeed;
    }
  }
}

// Cloud property change handlers
void onVentilationStatusChange() {
  Serial.print("Ventilation status changed to: ");
  Serial.println(ventilationStatus);
  digitalWrite(RELAY_PIN, ventilationStatus ? HIGH : LOW);
}

void onVentilationSpeedChange() {
  //Serial.print("Ventilation speed changed to: ");
  //Serial.println(ventilationSpeed);
    // Check if speed changed from medium to high
  if (ventilationSpeed == "high" && previousVentilationSpeed == "medium") {
    // This will trigger the notification in Arduino IoT Cloud
    Serial.println("â ï¸ AIR QUALITY IS POOR! Ventilation increased to high speed.");
  }
  // Check if speed changed from high to low
  else if (ventilationSpeed == "medium" && previousVentilationSpeed == "high") {
    // This will trigger the notification in Arduino IoT Cloud
    Serial.println("â AIR QUALITY IS NORMAL! Ventilation reduced to low speed.");
  }
  
  // Update previous speed
  previousVentilationSpeed = ventilationSpeed;
}