#include "arduino_secrets.h"
#include <Arduino_ConnectionHandler.h>
#include <ArduinoIoTCloud.h>
#include "thingProperties.h"  // This will be generated by Arduino IoT Cloud

#include <Wire.h>
#include <DHT.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_SSD1306.h>

// Pin Definitions
#define DHT_PIN 4
#define MQ135_PIN 34
#define RGB_RED_PIN 25
#define RGB_GREEN_PIN 26
#define RGB_BLUE_PIN 27
#define RELAY_PIN 16

// OLED Display
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// DHT Sensor
#define DHTTYPE DHT11
DHT dht(DHT_PIN, DHTTYPE);

// MQ135 Sensor
#define MQ135_CALIBRATION_SAMPLE_TIMES 50
#define MQ135_CALIBRATION_SAMPLE_INTERVAL 500

// Define thresholds
#define AIR_QUALITY_GOOD 800
#define AIR_QUALITY_MODERATE 1200


// Reading intervals
unsigned long previousMillis = 0;
const long interval = 2000;  // 2 seconds

// Moving average filter for MQ135
int mq135Readings[5] = {0};
int readIndex = 0;
int mq135Sum = 0;
int mq135Average = 0;

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  delay(1500);

  // Initialize pins
  pinMode(RGB_RED_PIN, OUTPUT);
  pinMode(RGB_GREEN_PIN, OUTPUT);
  pinMode(RGB_BLUE_PIN, OUTPUT);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, LOW); // Start with ventilation off

  // Initialize sensors
  initSensors();
  
  // Initialize display
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  display.setCursor(0, 0);
  display.println("Starting system...");
  display.display();

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information you'll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  display.println("Connecting to Cloud...");
  display.display();
}

void loop() {
  ArduinoCloud.update();
  
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    
    // Read sensors
    readSensors();
    
    // Update display
    updateDisplay();
    
    // Update RGB indicator
    updateRGBIndicator();
    
    // Control ventilation based on air quality
    controlVentilation();
  }
}

void initSensors() {
  dht.begin();
  
  // MQ135 warm-up message
  Serial.println("MQ135 warming up. For best results, allow several minutes for stabilization.");
  Serial.println("Taking initial readings for calibration...");
  
  // Take initial readings for calibration
  float mq135Sum = 0;
  for (int i = 0; i < MQ135_CALIBRATION_SAMPLE_TIMES; i++) {
    mq135Sum += analogRead(MQ135_PIN);
    delay(MQ135_CALIBRATION_SAMPLE_INTERVAL / 10);  // Reduced to speed up initial setup
  }
  
  // Calculate baseline
  float mq135Baseline = mq135Sum / MQ135_CALIBRATION_SAMPLE_TIMES;
  Serial.print("MQ135 baseline value: ");
  Serial.println(mq135Baseline);
}

void readSensors() {
  // Read DHT11 data
  float tempHumidity = dht.readHumidity();
  float tempTemperature = dht.readTemperature();
  
  // Check if DHT11 readings are valid
  if (isnan(tempHumidity) || isnan(tempTemperature)) {
    Serial.println("Failed to read from DHT sensor!");
  } else {
    humidity = tempHumidity;
    temperature = tempTemperature;
  }
  
  // Read MQ135 data with moving average filter
  // Remove the oldest reading from the sum
  mq135Sum = mq135Sum - mq135Readings[readIndex];
  
  // Read from the sensor
  mq135Readings[readIndex] = analogRead(MQ135_PIN);
  
  // Add the new reading to the sum
  mq135Sum = mq135Sum + mq135Readings[readIndex];
  
  // Advance to the next position in the array
  readIndex = (readIndex + 1) % 5;
  
  // Calculate the average
  mq135Average = mq135Sum / 5;
  
  // Convert analog reading to ppm (approximate)
  int tempAirQuality = map(mq135Average, 0, 4095, 400, 2000);
   
  // Convert ppm to percentage (0-100) for gauge display
  // Map 400-2000 ppm to 0-100%
  int airQualityPercentage = map(tempAirQuality, 400, 2000, 0, 100);
  
  // Store the percentage value for the gauge
  airQuality = airQualityPercentage;
  
  Serial.print("Temperature: ");
  Serial.print(temperature);
  Serial.print(" Â°C, Humidity: ");
  Serial.print(humidity);
  Serial.print(" %, Air Quality: ");
   Serial.print(airQualityPercentage);
  Serial.print("%, Raw PPM: ");
  Serial.print(tempAirQuality);
  Serial.println(" ppm CO2 eq.");
}

void updateDisplay() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("Air Quality Monitor");
  display.drawLine(0, 10, display.width(), 10, WHITE);
  
  // Temperature and Humidity
  display.setCursor(0, 15);
  display.print("Temp: ");
  display.print(temperature);
  display.println(" C");
  
  display.setCursor(0, 25);
  display.print("Humidity: ");
  display.print(humidity);
  display.println(" %");
  
  // Air Quality
  display.setCursor(0, 35);
  display.print("Air Quality: ");
  display.print(airQuality);
  display.println(" %");
  
  // Status text
  display.setCursor(0, 45);
  display.print("Status: ");
   // Convert percentage back to ppm for status check
  int tempAirQuality = map(airQuality, 0, 100, 400, 2000);
  if (tempAirQuality < AIR_QUALITY_GOOD) {
    display.println("GOOD");
  } else if (tempAirQuality < AIR_QUALITY_MODERATE) {
    display.println("MODERATE");
  } else {
    display.println("POOR");
  }
  
  // Ventilation status
  display.setCursor(0, 55);
  display.print("Vent: ");
  display.print(ventilationStatus ? "ON" : "OFF");
  if (ventilationStatus) {
    display.print(" (");
    display.print(ventilationSpeed);
    display.print(")");
  }
  
  display.display();
}

void updateRGBIndicator() {
  // Convert percentage back to ppm for RGB logic
  int tempAirQuality = map(airQuality, 0, 100, 400, 2000);
  if (tempAirQuality < AIR_QUALITY_GOOD) {
    // Good air quality - Green
    setRGBColor(0, 255, 0);
  } else if (tempAirQuality < AIR_QUALITY_MODERATE) {
    // Moderate air quality - Blue
    setRGBColor(0, 0, 255);
  } else {
    // Poor air quality - Red
    setRGBColor(255, 0, 0);
  }
}

void setRGBColor(int r, int g, int b) {
  // Note: Assuming common cathode RGB LED
  analogWrite(RGB_RED_PIN, r);
  analogWrite(RGB_GREEN_PIN, g);
  analogWrite(RGB_BLUE_PIN, b);
}

void controlVentilation() {
    // Convert percentage back to ppm for ventilation control
  int tempAirQuality = map(airQuality, 0, 100, 400, 2000);
  
  // Hysteresis control for ventilation
  if (tempAirQuality > AIR_QUALITY_GOOD && !ventilationStatus) {
    // Turn on ventilation if air quality is above good
    ventilationStatus = true;
    digitalWrite(RELAY_PIN, HIGH);
    Serial.println("Ventilation activated");
    
    // Set speed based on how poor the air quality is
    if (tempAirQuality > AIR_QUALITY_MODERATE + 200) {
      ventilationSpeed = "high";
      Serial.println("Ventilation speed set to high");
    } else if (tempAirQuality > AIR_QUALITY_GOOD + 100) {
      ventilationSpeed = "medium";
            Serial.println("Ventilation speed set to medium");
    } else {
      ventilationSpeed = "low";
      Serial.println("Ventilation speed set to low");
    }
  } 
  else if (tempAirQuality <= AIR_QUALITY_GOOD - 50 && ventilationStatus) {
    // Turn off ventilation if air quality has improved enough
    ventilationStatus = false;
    ventilationSpeed = "off";
    digitalWrite(RELAY_PIN, LOW);
    Serial.println("Ventilation deactivated");
  }
  else if (ventilationStatus) {
    // Add hysteresis to speed changes
    static int lastSpeedChange = 0;
    if (millis() - lastSpeedChange > 10000) {  // Only change speed every 10 seconds
      if (tempAirQuality > AIR_QUALITY_MODERATE + 200) {
        if (ventilationSpeed != "high") {
          ventilationSpeed = "high";
          Serial.println("Ventilation speed set to high");
          lastSpeedChange = millis();
        }
      } 
      else if (tempAirQuality > AIR_QUALITY_GOOD + 100) {
        if (ventilationSpeed != "medium") {
          ventilationSpeed = "medium";
          Serial.println("Ventilation speed set to medium");
          lastSpeedChange = millis();
        }
      }
      else {
        if (ventilationSpeed != "low") {
          ventilationSpeed = "low";
          Serial.println("Ventilation speed set to low");
          lastSpeedChange = millis();
        }
      }
    }
  }
}

// Cloud property change handlers
void onVentilationStatusChange() {
  Serial.print("Ventilation status changed to: ");
  Serial.println(ventilationStatus);
  digitalWrite(RELAY_PIN, ventilationStatus ? HIGH : LOW);
}

void onVentilationSpeedChange() {
  Serial.print("Ventilation speed changed to: ");
  Serial.println(ventilationSpeed);
}